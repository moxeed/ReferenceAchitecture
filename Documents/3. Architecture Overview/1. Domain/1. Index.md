![[Architecture Wheel.png]]

**Capture** and **model** business described by Product Owner, Solution Owner, Business Analyst, Product Manager. This module should be easily relate able to documents and business rules. The goal is to make sure nothing is processed by this module would be **against any business rule**.  Maintaining a **minimal code base** is a necessity to this module. It it advised to use prefixes and attributes and summary documentations to simplify code [[6. Code Navigation|navigation]].

The business consists of **data** and **behavior**. Both should be captured by domain. **Use cases** are built upon this model by leveraging the correct mutations to perform a transaction.
# Types

## Anemic
This domain is the simplest form. Database entities are created as POCOs. Checking business rules is delegated to database constrains and checks in business classes. However the checking still exists. Comparing this model with three-layer architecture, it will consist of Db Models, and Business Services.

In this model Business Services are treated as domain services, and should correspond to analytical documents.

### Characteristics
- Entities contain **fields + getters/setters only**.
- **Behavior lives in application services**, not entities.
- Easy to understand, but **poor encapsulation**.
- Business logic spreads across service classes.

### How It Captures Data
- Data is modeled as **POCOs**.
- Data shape closely reflects tables or DTOs.

**Example:**
```csharp
public class Order
{
	public Guid Id { get; set; }
	public Guid CustomerId { get; set; }
	public List<OrderItem> Items { get; set; } = new();
	public decimal TotalAmount { get; set; }
}
```
### How It Captures Behavior
- Behavior is placed in **Services**, not the entity.

**Example:**
```csharp
public class OrderService
{
	public void AddItem(Order order, Guid productId, int qty, decimal price)
	{
		order.Items.Add(new OrderItem { ProductId = productId, Quantity = qty, Price = price });
		order.TotalAmount = order.Items.Sum(i => i.Price * i.Quantity)
	}
}
```

### Modeling Style Summary
- **Pro:** Simple, predictable.
- **Con:** No invariant protection inside model. Risk of inconsistent states.
- **Use When:** Simple CRUD systems.
## Business Rule Driven
This is the hybrid model between Domain Driven, which captures all business behavior, and anemic model which only captures data model. In this model the core concept in domain is business rules and should be separate classes. Entities provide mutation methods (not behavioral, meaning only change state based on input), and checking related business rules after the mutation.

Unit test verify the business rules, and business rules verify mutations. In this model, behavior is part of domain but not part of entity. the entity is only responsible to ensure mutation integrity.

### Characteristics
- Entities have minimal helper behavior but **not full domain logic**.
- Business rules live in **dedicated rule units**.
- Rules operate over entities and return results or mutations.
- Preserves data integrity without full DDD complexity.

### How It Captures Data
- Same entities as anemic, but with some guard rails.

```csharp
public class Order
{
	public Guid Id { get; set; }
	public Guid CustomerId { get; set; }
	public List<OrderItem> Items { get; set; } = new();
}
```

### How It Captures Behavior

Behavior is split:
- **Services**: Structural helpers.
- **Rules**: Enforce all business constraints.

Example Rule Unit

```csharp
public class AddItemRule : IBusinessRule
{
	public RuleResult Apply(Order order, AddItemCommand cmd)
	{
		if (cmd.Quantity <= 0)
			return RuleResult.Fail("Quantity must be positive.");
		
		order.Items.Add(new OrderItem(cmd.ProductId, cmd.Quantity, cmd.Price));
		return RuleResult.Success();
	}
}
```

- [ ] #Q Does Rule Engine Fits This Model?

### Modeling Style Summary
- **Pro:** Centralized rules, maintainable, domain-agnostic.
- **Con:** Entities still weak, not as expressive as DDD.
- **Use When:** Medium complexity business systems needing integrity but not full DDD.
## Domain Driven Design
The most complete model to capture every detail of business into the lowest level possible (entities). while complex it could completely enforce invariants both on data and behavior, event preventing unexpected sequences in workflow.
### Characteristics
- Entities hold **business logic + invariants**.
- Data and behavior are tightly coupled.
- Interactions happen through meaningful domain operations.
### How It Captures Data
- Data still stored as fields, but protected.

```csharp
public class Order : AggregateRoot
{
	private readonly List<OrderItem> _items = new();
	
	public Guid CustomerId { get; }
	public IReadOnlyCollection<OrderItem> Items => _items;
	
	public Money Total => new(_items.Sum(x => x.LineTotal.Value));
}
```

### How It Captures Behavior
- Behavior is modeled as **domain operations**.
- Entities enforce **invariants** internally.

```csharp
public void AddItem(Guid productId, int qty, Money price)
{
	if (qty <= 0)
		throw new DomainException("Quantity must be positive.");
	
	_items.Add(new OrderItem(productId, qty, price));
}
```

### Modeling Style Summary
- **Pro:** Strong encapsulation, invariant safety.
- **Con:** More complex, requires careful design.
- **Use When:** Complex business domain, long-lived software.