
>[!summary]
> Script → Program → Prototype → Module → Component → Service → Framework-Based System → Domain Model System → Specified System → Formal System

### 1. Script-Level Terms (Low Complexity, Low Clarity)

These appear at the bottom of the spectrum.
- **Script**
- **Ad-hoc Program**
- **One-off Utility**
- **Hacked-Together Code**
- **Glue Code**
- **Prototype Script**
- **Throwaway Code**

Characteristics:
- Hardcoded control flow
- No architecture
- Behavior defined only by implementation
- Non-reusable, non-testable
### 2. Early Structured Software

Slightly clearer, but not yet architectural.
- **Procedural Program**
- **Structured Script**
- **Function-Based Program**
- **Batch Process**
- **Pipeline Script**
- **Utility Program**

Characteristics:
- Functions and modules exist
- Linear flow with reusable parts
- Minimal separation of concerns

## 3. Prototype-Level Software

Early design thinking appears.
- **Prototype**
- **Proof of Concept (POC)**
- **MVP (Minimum Viable Product)**
- **Technical Spike**
- **Exploratory Implementation**

Characteristics:
- Incomplete
- Behavior still changing
- Architecture only beginning to exist

## 4. Modular Software

Well-formed internal structure starts.
- **Modular System**
- **Library**
- **Package**
- **Subsystem**
- **Reusable Component**

Characteristics:
- Explicit modules
- Defined interfaces
- Stable boundaries

## 5. Component-Based Software (Mid-Spectrum)

Clearer design and reuse.
- **Component System**
- **Service**
- **Microservice**
- **Plugin**
- **Architectured System**
- **Layered Architecture**
- **SOA (Service-Oriented Architecture)**

Characteristics:
- Contracts govern interactions
- Components can be replaced or refactored independently

## 6. Model-Driven / Config-Driven Software

Behavior is extracted from code into models or configuration.
- **Model-Driven Software**
- **DSL-DrivenSystem**
- **Configuration-Oriented System**
- **Declarative Software**
- **Schema-Driven Software**
- **Business Rule Engine**
- **Workflow-Driven System**

Characteristics:
- Logic defined by specifications outside the code
- The system is controlled by configuration, rules, or models

## 7. Framework-Based Software

The framework becomes the architecture.
- **Framework-Based Application**
- **Convention Over Configuration App**
- **Opinionated System**
- **Inversion-of-Control (IoC) System**
- **MVC/MVVM/MVP Application**

Characteristics:
- Control flow dictated by framework
- Application code is “filled in” around predefined architecture

## 8. Domain-Driven Software (High Clarity)

Behavior aligned with domain semantics.
- **Domain-Driven System**
- **DDD Layered Architecture**
- **Hexagonal Architecture**
- **Clean Architecture**
- **Ports and Adapters**
- **Use-Case Driven Application**

Characteristics:
- Clear domain boundaries
- Explicit application services
- Behavior expressed in domain language

## 9. Specification-Based Software (High Complexity / High Clarity)

Software is driven by requirements, rules, or contracts.
- **Specification-Based Software**
- **Contract-Driven Development**
- **Property-Based Development**
- **Test-Driven Development (when used as specification)**
- **Requirements-Based System**
- **Formal Requirements Model**

Characteristics:
- Test/spec documentation becomes the source of truth
- Implementation verifies behavior defined elsewhere

## 10. Formal Software (Highest Clarity)

Used in aerospace, medical, safety-critical.
- **Formal Specification**
- **Verified Software**
- **Mathematically Modeled System**
- **Provably Correct Software**
- **Model-Checked Implementation**
- **TLA+/Z/Alloy-Based System**
- **Safety-Critical Software**

Characteristics:
- Behavior fully defined by mathematical models
- Implementation verified against formal spec