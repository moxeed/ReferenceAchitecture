## 1. Browsing Navigation
Directly reading through folders and files.

**Patterns**
- Opening folders, scanning file names
- Jumping between modules or packages
- Following imports manually

**Optimizations**
- Clear, consistent file/folder naming
- Domain-based or feature-based structure
- Shallow directory depth
- Grouping related files (e.g., `Order/OrderService.cs`, `Order/OrderController.cs`)
- Dedicated “entry points” (index files, barrels, module entrypoints)
---
## 2. Search Navigation
Using keyword search or IDE search.

**Patterns**
- Searching for class/function names
- Searching for string literals or identifiers
- Searching for interfaces/implementations

**Optimizations**
- Consistent terminology across modules
- Avoid ambiguous names (`Manager`, `Util`, `Handler`)
- Prefer domain language over vague abstractions
- Break down large files to reduce search noise
- Semantic naming (e.g., `Rule_CalculateTax`, `Query_GetActiveUsers`)
---
## 3. Jump-to-Definition Navigation
Using IDE “Go to definition” and “Peek definition”.

**Patterns**
- Navigating from call sites to definitions
- Tracing code paths through layers
- Checking interface implementations

**Optimizations**
- Avoid reflection-heavy logic
- Minimize dynamic meta-programming
- Prefer explicit interfaces over magic behavior
- Use strongly typed APIs
- Keep public APIs small and intentional
---
## 4. Reference Navigation
IDE “Find references”, reverse lookup from usage.

**Patterns**
- Finding all call sites of a function
- Tracing mutation flows
- Understanding event flows or callbacks

**Optimizations**
- Avoid global state
- Use dependency injection interfaces
- Make side effects explicit
- Prefer signals/events over hidden callbacks
- Avoid complex inheritance chains
---
## 5. Flow Navigation

Following the execution flow.
**Patterns**
- Tracing request → controller → service → domain → persistence
- Tracing asynchronous flows
- Following middleware pipelines
- Debug stepping

**Optimizations**
- Keep architecture consistent (onion, clean architecture)
- Predictable module boundaries
- Limit levels of indirection
- Use named pipes/middlewares instead of anonymous lambdas
---
## 6. Structural Navigation
Understanding code by its shape: classes, modules, packages.

**Patterns**
- Tree exploration in IDE
- Jumping between class/interface hierarchies
- Grouping by domain or feature

**Optimizations**
- Domain-based structure over technical layering when possible
- Avoid “god modules”
- Minimize cyclical dependencies
- Prefer composition over inheritance
---
## 7. Conceptual Navigation
Finding where ideas live in the codebase.

**Patterns**
- Where is the validation logic?
- Where are business rules?
- Where is orchestration?
- Where is configuration?

**Optimizations**
- Clear architectural boundaries
- Use naming conventions to mark responsibilities:
    - `Rule_*, Mutate_*, Validate_*`
- Encapsulate domain logic in domain layer
- Keep infrastructure isolated
---
## 8. Temporal Navigation
Understanding changes over time.
**Patterns**
- Git blame
- Git history
- Browsing PRs
- Checking commit evolution of a file

**Optimizations**
- Meaningful commit messages
- Small atomic commits
- Avoid committing generated or noisy files
- Keep files focused to reduce diff size
---
## 9. Semantic Navigation
Using language-server or IDE semantic tools.

**Patterns**
- Symbol search
- Type hierarchy
- Call hierarchy

**Optimizations**
- Strong typing
- Avoid runtime duck typing
- Use interfaces to constrain contracts
- Keep functions small enough for LSPs to index clearly
---
# How to Optimize Codebases for Easy Navigation

## 1. Use Feature or Domain-Based Folder Structure

```css
/Order
   OrderController.cs
   OrderService.cs
   OrderRules.cs
   OrderRepository.cs
```
## 2. Make Things Discoverable
- Consistent naming
- One class/thing per file
- Keep file names matching class names exactly
## 3. Reduce Magic & Reflection
Magic code breaks “Go to definition”.
## 4. Keep Layers Predictable
- controllers → services → domain → infra
- No circular or cross-layer detours
## 5. Simplify Interfaces
Large interfaces make reference tracing hard.
## 6. At Most 2–3 Levels of Indirection
If it takes more than three jumps to understand something, architecture is too fragmented.
## 7. Document “Where Things Live”
A simple `ARCHITECTURE.md` clarifies:
- where rules go
- where queries go
- where mutations go
- where workflows go
## 8. Create Codebase-Level Vocabulary
Examples:
- `Rule_`: a domain rule
- `Query_`: a data query
- `Command_`: a write operation
- `Workflow_`: orchestrates multiple operations

This unifies navigation mentally and through search.