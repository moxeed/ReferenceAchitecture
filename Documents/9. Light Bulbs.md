- Domain Entity is like a rest resource and could be requested to be modified by any one, though the validation of changes is upon the resource. It should maintain its own integrity. 
![[Database Tier of Mark Logic.png]]
![[MarkLogic-RefArch.pdf]]

---

- Software are somewhere between script and specification spectrum. 
1. Script
2. Utility
3. Program
4. Application
5. System
6. Model
7. Specification

---

- Controller and Datapath model from CPU architecture properly defines an application. Script is a full controller app and specification is a full data path app.

---

## The Model 

### Single Controller, Nested Data Paths.
X: Rejected
- This is so limiting and completely void modularization and encapsulation

### Pipeline
Each node calls one node until the process in done.
X: Rejected
- Does not handle orchestration and cross entity flows properly. only feasible if all operations and commands are handled with a single direct flow.
- It provides the benefit of reusable logic, but limits the composition of two logics at same level which happen most of the time.
- This is a proper method to implement handle section of application. not the domain.

### Control Tree
Each node may have a controller and can invoke any number of nodes and must coordinate them.
OK
- The goal is two minimize branching factor and tiers with controllers to simplify the code if possible. This means control logic should be placed by this priority
	1. Application Service
	2. Domain Service
	3. Aggregate
	4. Entity
- No unit should assume anything about the internal implementations. every input and output should be validated and addressed accordingly if incorrect. (This could be dropped for performance considerations, but improving design to terminate the root of problem is encouraged)

### Choreography

Each node does its own thing and notifies other nodes through indirect events. This approach requires precise event design and should avoid infinite event loops. Thus it is the most complex yet most loose method.
From experience, designing such in-memory flows are exhausting, and prevents fast adaptation to changes.

### Hybrid 
Control Tree at implementation, choreography at integration.

---

### Script
The highest level code to describe a flow, without any particular patterns, engineering complexities and future proof identities. This is a half software as it only describes the controller section of application and propagates all data flow responsibilities to underlying software.

### Utility
The purest reusable software have two blocks. The handles and the logic. Such software is only dependent on the OS, and its lifetime is described as below.
1. Start
2. Accept an command from handles
3. Respond to handle
4. Die
examples are Linux terminal commands.

### Application
The data path emerges. Application is responsible to manage state and maintain its integrity. Tiers and Layers are the most common approaches to handle this kind of software. Now the infrastructure is part of the software and should be managed properly. Yet, the domain layer still exists and only has been enabled on another infrastructure that is not default.

---
**Comparison: Explicit vs MediatR**

| **Aspect**             | **MediatR**  | **Explicit Services** | **Feature Use Cases** |
| ---------------------- | ------------ | --------------------- | --------------------- |
| **Dependency Clarity** | ❌ Hidden     | ✅ **Very Clear**      | ✅ **Crystal Clear**   |
| **Traceability**       | ❌ Magic      | ✅ **Direct**          | ✅ **Direct**          |
| **Discovery**          | ❌ Scan-based | ✅ **Interface-based** | ✅ **Folder-based**    |
| **Testing**            | ✅ Easy       | ✅ **Easier**          | ✅ **Easiest**         |
| **Pipeline**           | ✅ Built-in   | ⚠️ Manual             | ⚠️ Manual             |
| **Learning Curve**     | ❌ Medium     | ✅ **None**            | ✅ **Minimal**         |
| **IDE Support**        | ⚠️ Mixed     | ✅ **Perfect**         | ✅ **Perfect**         |